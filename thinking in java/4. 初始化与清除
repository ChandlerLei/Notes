1. 函数的重载
这个本身没什么好说的，这里给出了为何我们不能把函数的返回类型不同而进行重载呢？
void f(){}
int f(){}
假设此时我们调用函数：
f(); //此时编译器根本不知道应该调用哪个函数，所以不能进行重载。

2. this关键字
-- 当前对象
class A{
	public void f(int i){}
}
A a1 = new A(); A a2 = new A();
a1.f(2);
a2.f(3);
其实这两个语句内部表达是这样的：
A.f(a1, 2);
A.f(a2, 3);
这里传递给f的还有这个对象的句柄。所以我们在类方法中，可以通过this来获得这个对象句柄。

this的另一个用途：在构造器里调用构造器
class A{
	public A(int i){}
	public A(int i, String s){}
	public A(){
		this(2); //or this(2, "123");
	}
}
注意几点：
只能在构造器里这么用this，其他函数不可以。
this语句只能有一条，且必须出现在第一行。

3. finalize
在Java中，提供了一种叫做“收尾”的机制。
即在类中定义finalize函数，这样此对象在被垃圾回收器释放内存的时候会先调用finalize函数。
但是注意：在Java中你不可能知道某个对象在何时被gc释放内存。意味着你不可能知道何时——甚至是否——finalize( )被调用。
因为有的对象，JVM可能直到程序的退出时，也不会释放对象的内存。这些内存会随着程序的退出而归还给OS。--Java的思想是：gc回收也会消耗资源，如果不到内存快不够用的时候，它是不会进行垃圾回收的。
建议：不建议使用这个机制。

4. Java中类成员变量初始化
按照先后顺序进行初始化。
所有变量的初始化都是在所有成员函数调用之前做的（包括构造器函数）--如果在构造器中对变量进行“初始化”，其实此时变量已经初始化，构造器中只是再一次赋值。
class Aaa {
    public int j = i; // Error
    public void f(){
        System.out.println(i); // OK
    }
    public int i;
}

5. Java中类static成员变量初始化
我们知道static成员变量初始化是在普通成员变量之前的，
但是要注意：如果这个类从没有被创建，而且永远不引用这个类中的static变量，那么这个static变量是不会初始化的。
类的static变量，只有在第一次类对象被创建（或者第一次被引用类static变量）时，才会被初始化。并且在第一次初始化之后不会再进行初始化。

6. Java中的初始化块
class A{
	int i;
	{
		i = 2;
		String s = "123";//这样做是几乎没有意义的，因为s的作用域只是在大括号内。
	}
	static int j;
	static {
		j = 3;
	}
}
Java中初始化块和变量初始化的顺序是根据初始化语句的先后顺序决定的。

7. Java中数组的初始化
(1) 定义的时候使用{}来初始化
int[] a = {1,2,3};
int[] a = new int[]{1,2,3};
基本类型与“非基本类型”都是一样的。
A[] as = {new A(), new A()};
(2) 普通的new来初始化
int[] a;
a = new int[5];
A[] b;
b = new A[3];
注意的是此时a和b已被初始化默认值，即a数组中所有元素为0，b中所有元素为null。
这点和类成员变量类似。

多维数组和一维的类似：
int[][] a = {{1,2,3},{2,3,4}};
int[][] a = {{1,2,3},{2,3}};//也是ok的，注意a[1][2]是越界错误的。
多维数组应该被看做是数组的数组，而不应该看成矩阵，因为它可能并不是矩阵。
int[][] a = new int[2][3];
int[][] b = mew int[2][];
for (i)
	b[i] = new int[i];
对象数组和基本类型数组一致的。
